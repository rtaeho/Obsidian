- Interrupt processing에서 PC와 PSW를 저장하는 작업을 왜 hardware에서 하는가?
	-> *hardware적 작업 마지막에 PC값을 불러오며 software로 전환되기에, 그 전에 PC값을 미리 저장해놔야함*
	
- cache는 왜 os가 아닌 hardware가 관리하는가?
	-> *캐시를 사용하는 이유가 속도 향상을 위해서인데, os가 관리하는 순간 느려짐*
	
- Unix Process State Transition Diagram에서 Preempted -> User Running으로 kernel running 없이 바로 가는 것 처럼 하나의 화살표로 그려져있는데, 실제로는 OS작업을 거쳐간다. 그럼에도 불구하고 이렇게 나타난 이유는 무엇인가?
	-> 
	
- User Level Thread에서 process가 block됐음에도 thread는 왜 running상태인가?
	-> *thread를 block으로 바꿔야 하지만 process가 이미 block되었기에 thread library가 멈춤*
	
- Dekker's Algorithm에서 C.S에 들어갔다가 나온 process가 상대 process가 내부 반복문을 돌고 있음에도 불구하고 다시 C.S에 진입이 가능한가?
	-> *가능하다. C.S를 마치고 나온 프로세스가 turn값을 바꾼 후 time-out에 걸리면 상대 프로세스가 내부 반복문을 빠져나와서 외부 반복문을 돌게 되는데, 이 때 다시 time-out에 걸리면 다시 원래 프로세스가 C.S에 진입이 가능하다.*
	
- Dekker's Algorithm에서 2개의 대기 상태 (내부 반복문, 외부 반복문)에서 외부 반복문을 돌다가 내부 반복문을 도는 것이 가능한가?
	-> *불가능하다. 외부 반복문을 도는 경우는 flag가 상대 프로세스의 값이고 turn은 나의 프로세스 값인 경우인데, 여기서 내부 반복문을 돌기 위해서는 turn값이 상대 프로세스의 값으로 바뀌어야 한다. 하지만 본인 프로세스의 turn값으로 바꾸는 것은 불가능하기에 결국 불가능하다.*
	
- Dekker's Algorithm에서 2개의 대기 상태 (내부 반복문, 외부 반복문)에서 내부 반복문을 돌다가 외부 반복문을 도는 것이 가능한가?
	-> *가능하다. 내부 반복문을 도는 경우는 flag가 상대 프로세스의 값인 채로 진입하고 turn도 상대 프로세스의 값인 경우인데, 여기서 외부 반복문을 돌기 위해서는 turn값이 나의 프로세스의 값으로 바뀌어야 한다. 상대 프로세스가 C.S를 나와서 turn값을 바꾼 뒤 time-out이 걸리면 나의 프로세스는 외부 반복문을 돌게 된다.*